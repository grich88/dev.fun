{"ast":null,"code":"import CryptoJS from 'crypto-js';\nimport { v4 as uuidv4 } from 'uuid';\nexport class GameService {\n  constructor() {\n    this.games = new Map();\n    this.players = new Map();\n    this.houseWallet = 'HOUSE_WALLET_MOCK';\n    this.entryFee = 5; // PUMP tokens\n    this.houseFee = 0.05; // 5%\n    this.initialized = false;\n  }\n  initialize() {\n    if (this.initialized) return;\n    console.log('ðŸŽ² GameService initialized');\n    this.initialized = true;\n\n    // Mock some initial data - increase house balance to handle larger bets\n    this.mockHouseBalance = 1000000; // 1 million PUMP tokens\n  }\n\n  // Generate pseudo-random coin flip using current timestamp and player address\n  generateCoinFlip(gameId, playerAddress) {\n    const seed = Date.now().toString() + gameId + playerAddress;\n    const hash = CryptoJS.SHA256(seed).toString();\n    const randomValue = parseInt(hash.substring(0, 8), 16);\n    return randomValue % 2 === 0 ? 'heads' : 'tails';\n  }\n\n  // Join multiplayer game\n  async joinMultiplayerGame(playerAddress) {\n    var _gameData$players$gam;\n    console.log('ðŸŽ® Joining multiplayer game:', playerAddress);\n\n    // Simulate wallet balance check\n    await this.simulateDelay(500);\n    if (!playerAddress) {\n      throw new Error('Wallet not connected');\n    }\n\n    // Find existing game or create new one\n    let gameId = this.findActiveMultiplayerGame();\n    let gameData;\n    if (!gameId) {\n      // Create new game\n      gameId = uuidv4();\n      gameData = {\n        gameId,\n        type: 'multiplayer',\n        status: 'waiting',\n        players: [],\n        potSize: 0,\n        houseFee: 0,\n        currentPlayerIndex: 0,\n        createdAt: Date.now(),\n        maxPlayers: 8,\n        entryFee: this.entryFee\n      };\n      this.games.set(gameId, gameData);\n    } else {\n      gameData = this.games.get(gameId);\n    }\n\n    // Check if player already in game\n    const existingPlayer = gameData.players.find(p => p.address === playerAddress);\n    if (existingPlayer) {\n      throw new Error('Already in this game');\n    }\n\n    // Add player to game\n    const player = {\n      address: playerAddress,\n      nickname: `Player${gameData.players.length + 1}`,\n      streak: 0,\n      maxStreak: 0,\n      status: 'waiting',\n      joinedAt: Date.now(),\n      hasPaid: true // Mock payment\n    };\n    gameData.players.push(player);\n    gameData.potSize += this.entryFee;\n\n    // Start game if we have 2+ players\n    if (gameData.players.length >= 2 && gameData.status === 'waiting') {\n      gameData.status = 'active';\n      gameData.startedAt = Date.now();\n      gameData.players[0].status = 'playing';\n    }\n    this.games.set(gameId, gameData);\n    return {\n      gameId,\n      players: gameData.players,\n      potSize: gameData.potSize,\n      houseFee: Math.round(gameData.potSize * this.houseFee * 100) / 100,\n      currentPlayer: (_gameData$players$gam = gameData.players[gameData.currentPlayerIndex]) === null || _gameData$players$gam === void 0 ? void 0 : _gameData$players$gam.address,\n      isPlayerTurn: gameData.currentPlayerIndex === gameData.players.length - 1,\n      gameStatus: gameData.status\n    };\n  }\n\n  // Start solo game\n  async startSoloGame(playerAddress, betAmount) {\n    console.log('ðŸŽ² Starting solo game:', playerAddress, 'bet:', betAmount);\n    await this.simulateDelay(300);\n    if (!playerAddress) {\n      throw new Error('Wallet not connected');\n    }\n    if (betAmount < 1 || betAmount > 100) {\n      throw new Error('Bet amount must be between 1 and 100 PUMP tokens');\n    }\n\n    // Check house balance - max streak of 7 for safety\n    const maxPayout = betAmount * Math.pow(2, 7);\n    if (this.mockHouseBalance < maxPayout) {\n      throw new Error(`House insufficient funds for this bet (max payout: ${maxPayout} PUMP)`);\n    }\n    const gameId = uuidv4();\n    const gameData = {\n      gameId,\n      type: 'solo',\n      status: 'active',\n      playerAddress,\n      betAmount,\n      currentStreak: 0,\n      maxStreak: 0,\n      createdAt: Date.now(),\n      houseBalance: this.mockHouseBalance\n    };\n    this.games.set(gameId, gameData);\n    return {\n      gameId,\n      betAmount,\n      currentStreak: 0,\n      maxStreak: 0,\n      potentialPayout: betAmount * 2,\n      houseBalance: this.mockHouseBalance,\n      isPlayerTurn: true,\n      gameStatus: 'active'\n    };\n  }\n\n  // Flip coin\n  async flipCoin(gameId, playerAddress) {\n    console.log('ðŸª™ Flipping coin:', gameId, playerAddress);\n    await this.simulateDelay(1000); // Simulate coin flip animation time\n\n    const gameData = this.games.get(gameId);\n    if (!gameData) {\n      throw new Error('Game not found');\n    }\n    const outcome = this.generateCoinFlip(gameId, playerAddress);\n    console.log('Flip result:', outcome);\n    if (gameData.type === 'solo') {\n      return this.handleSoloFlip(gameData, outcome);\n    } else {\n      return this.handleMultiplayerFlip(gameData, playerAddress, outcome);\n    }\n  }\n\n  // Handle solo mode flip\n  handleSoloFlip(gameData, outcome) {\n    if (outcome === 'heads') {\n      gameData.currentStreak += 1;\n      gameData.maxStreak = Math.max(gameData.maxStreak, gameData.currentStreak);\n      const potentialPayout = gameData.betAmount * Math.pow(2, gameData.currentStreak);\n      return {\n        outcome: 'heads',\n        streak: gameData.currentStreak,\n        maxStreak: gameData.maxStreak,\n        potentialPayout,\n        isPlayerTurn: true,\n        status: 'active'\n      };\n    } else {\n      // Bust\n      gameData.status = 'finished';\n      gameData.currentStreak = 0;\n      gameData.finishedAt = Date.now();\n\n      // House wins the bet\n      this.mockHouseBalance += gameData.betAmount;\n      return {\n        outcome: 'tails',\n        streak: 0,\n        maxStreak: gameData.maxStreak,\n        potentialPayout: 0,\n        isPlayerTurn: false,\n        status: 'busted'\n      };\n    }\n  }\n\n  // Handle multiplayer flip\n  handleMultiplayerFlip(gameData, playerAddress, outcome) {\n    const playerIndex = gameData.players.findIndex(p => p.address === playerAddress);\n    if (playerIndex === -1) {\n      throw new Error('Player not in game');\n    }\n    const player = gameData.players[playerIndex];\n    if (gameData.currentPlayerIndex !== playerIndex) {\n      throw new Error('Not your turn');\n    }\n    if (outcome === 'heads') {\n      player.streak += 1;\n      player.maxStreak = Math.max(player.maxStreak, player.streak);\n      return {\n        outcome: 'heads',\n        streak: player.streak,\n        maxStreak: player.maxStreak,\n        isPlayerTurn: true,\n        status: 'active'\n      };\n    } else {\n      // Bust - move to next player\n      player.status = 'busted';\n      player.streak = 0;\n\n      // Find next active player\n      const nextPlayerIndex = this.findNextActivePlayer(gameData);\n      if (nextPlayerIndex === -1) {\n        // Game over - determine winner\n        this.endMultiplayerGame(gameData);\n      } else {\n        gameData.currentPlayerIndex = nextPlayerIndex;\n        gameData.players[nextPlayerIndex].status = 'playing';\n      }\n      return {\n        outcome: 'tails',\n        streak: 0,\n        maxStreak: player.maxStreak,\n        isPlayerTurn: false,\n        status: player.status\n      };\n    }\n  }\n\n  // Cash out\n  async cashOut(gameId, playerAddress) {\n    console.log('ðŸ’° Cashing out:', gameId, playerAddress);\n    await this.simulateDelay(500);\n    const gameData = this.games.get(gameId);\n    if (!gameData) {\n      throw new Error('Game not found');\n    }\n    if (gameData.type === 'solo') {\n      gameData.status = 'cashed_out';\n      gameData.finalStreak = gameData.currentStreak;\n      gameData.finishedAt = Date.now();\n      const payout = gameData.betAmount * Math.pow(2, gameData.currentStreak);\n      this.mockHouseBalance -= payout;\n      return {\n        streak: gameData.currentStreak,\n        payout,\n        status: 'cashed_out'\n      };\n    } else {\n      const playerIndex = gameData.players.findIndex(p => p.address === playerAddress);\n      const player = gameData.players[playerIndex];\n      player.status = 'cashed_out';\n      player.finalStreak = player.streak;\n\n      // Move to next player\n      const nextPlayerIndex = this.findNextActivePlayer(gameData);\n      if (nextPlayerIndex === -1) {\n        this.endMultiplayerGame(gameData);\n      } else {\n        gameData.currentPlayerIndex = nextPlayerIndex;\n        gameData.players[nextPlayerIndex].status = 'playing';\n      }\n      return {\n        streak: player.streak,\n        status: 'cashed_out'\n      };\n    }\n  }\n\n  // Claim winnings\n  async claimWinnings(gameId, playerAddress) {\n    console.log('ðŸ† Claiming winnings:', gameId, playerAddress);\n    await this.simulateDelay(1000);\n    const gameData = this.games.get(gameId);\n    if (!gameData) {\n      throw new Error('Game not found');\n    }\n    if (gameData.type === 'solo') {\n      if (gameData.status !== 'cashed_out') {\n        throw new Error('No winnings to claim');\n      }\n      const payout = gameData.betAmount * Math.pow(2, gameData.finalStreak);\n\n      // Clean up game\n      this.games.delete(gameId);\n      return {\n        amount: payout,\n        type: 'solo'\n      };\n    } else {\n      if (gameData.status !== 'finished') {\n        throw new Error('Game not finished');\n      }\n      const winner = gameData.players.find(p => p.address === playerAddress);\n      if (!winner || !winner.isWinner) {\n        throw new Error('You are not the winner');\n      }\n      const totalPot = gameData.potSize;\n      const houseFeeAmount = totalPot * this.houseFee;\n      const winnings = totalPot - houseFeeAmount;\n\n      // Clean up game\n      this.games.delete(gameId);\n      return {\n        amount: winnings,\n        type: 'multiplayer',\n        houseFee: houseFeeAmount\n      };\n    }\n  }\n\n  // Helper methods\n  findActiveMultiplayerGame() {\n    for (const [gameId, gameData] of this.games) {\n      if (gameData.type === 'multiplayer' && gameData.status === 'waiting' && gameData.players.length < gameData.maxPlayers) {\n        return gameId;\n      }\n    }\n    return null;\n  }\n  findNextActivePlayer(gameData) {\n    for (let i = gameData.currentPlayerIndex + 1; i < gameData.players.length; i++) {\n      if (gameData.players[i].status === 'waiting') {\n        return i;\n      }\n    }\n    return -1;\n  }\n  endMultiplayerGame(gameData) {\n    gameData.status = 'finished';\n    gameData.finishedAt = Date.now();\n\n    // Find winner (highest streak)\n    let winner = null;\n    let highestStreak = -1;\n    for (const player of gameData.players) {\n      var _player$finalStreak;\n      const finalStreak = (_player$finalStreak = player.finalStreak) !== null && _player$finalStreak !== void 0 ? _player$finalStreak : player.maxStreak;\n      if (finalStreak > highestStreak) {\n        highestStreak = finalStreak;\n        winner = player;\n      }\n    }\n    if (winner) {\n      winner.isWinner = true;\n      gameData.winner = winner.address;\n    }\n  }\n  simulateDelay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // Get game state\n  getGameState(gameId) {\n    return this.games.get(gameId);\n  }\n\n  // Get payout table for solo mode\n  getPayoutTable(betAmount = 1) {\n    const payouts = [];\n    for (let streak = 1; streak <= 10; streak++) {\n      payouts.push({\n        streak,\n        payout: betAmount * Math.pow(2, streak),\n        odds: `1 in ${Math.pow(2, streak)}`\n      });\n    }\n    return payouts;\n  }\n\n  // Get game statistics\n  getGameStats() {\n    return {\n      activeGames: this.games.size,\n      houseBalance: this.mockHouseBalance,\n      totalPlayers: this.players.size\n    };\n  }\n}","map":{"version":3,"names":["CryptoJS","v4","uuidv4","GameService","constructor","games","Map","players","houseWallet","entryFee","houseFee","initialized","initialize","console","log","mockHouseBalance","generateCoinFlip","gameId","playerAddress","seed","Date","now","toString","hash","SHA256","randomValue","parseInt","substring","joinMultiplayerGame","_gameData$players$gam","simulateDelay","Error","findActiveMultiplayerGame","gameData","type","status","potSize","currentPlayerIndex","createdAt","maxPlayers","set","get","existingPlayer","find","p","address","player","nickname","length","streak","maxStreak","joinedAt","hasPaid","push","startedAt","Math","round","currentPlayer","isPlayerTurn","gameStatus","startSoloGame","betAmount","maxPayout","pow","currentStreak","houseBalance","potentialPayout","flipCoin","outcome","handleSoloFlip","handleMultiplayerFlip","max","finishedAt","playerIndex","findIndex","nextPlayerIndex","findNextActivePlayer","endMultiplayerGame","cashOut","finalStreak","payout","claimWinnings","delete","amount","winner","isWinner","totalPot","houseFeeAmount","winnings","i","highestStreak","_player$finalStreak","ms","Promise","resolve","setTimeout","getGameState","getPayoutTable","payouts","odds","getGameStats","activeGames","size","totalPlayers"],"sources":["C:/dev.fun/src/services/GameService.js"],"sourcesContent":["import CryptoJS from 'crypto-js';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nexport class GameService {\r\n  constructor() {\r\n    this.games = new Map();\r\n    this.players = new Map();\r\n    this.houseWallet = 'HOUSE_WALLET_MOCK';\r\n    this.entryFee = 5; // PUMP tokens\r\n    this.houseFee = 0.05; // 5%\r\n    this.initialized = false;\r\n  }\r\n\r\n  initialize() {\r\n    if (this.initialized) return;\r\n    \r\n    console.log('ðŸŽ² GameService initialized');\r\n    this.initialized = true;\r\n    \r\n    // Mock some initial data - increase house balance to handle larger bets\r\n    this.mockHouseBalance = 1000000; // 1 million PUMP tokens\r\n  }\r\n\r\n  // Generate pseudo-random coin flip using current timestamp and player address\r\n  generateCoinFlip(gameId, playerAddress) {\r\n    const seed = Date.now().toString() + gameId + playerAddress;\r\n    const hash = CryptoJS.SHA256(seed).toString();\r\n    const randomValue = parseInt(hash.substring(0, 8), 16);\r\n    return (randomValue % 2) === 0 ? 'heads' : 'tails';\r\n  }\r\n\r\n  // Join multiplayer game\r\n  async joinMultiplayerGame(playerAddress) {\r\n    console.log('ðŸŽ® Joining multiplayer game:', playerAddress);\r\n    \r\n    // Simulate wallet balance check\r\n    await this.simulateDelay(500);\r\n    \r\n    if (!playerAddress) {\r\n      throw new Error('Wallet not connected');\r\n    }\r\n\r\n    // Find existing game or create new one\r\n    let gameId = this.findActiveMultiplayerGame();\r\n    let gameData;\r\n\r\n    if (!gameId) {\r\n      // Create new game\r\n      gameId = uuidv4();\r\n      gameData = {\r\n        gameId,\r\n        type: 'multiplayer',\r\n        status: 'waiting',\r\n        players: [],\r\n        potSize: 0,\r\n        houseFee: 0,\r\n        currentPlayerIndex: 0,\r\n        createdAt: Date.now(),\r\n        maxPlayers: 8,\r\n        entryFee: this.entryFee\r\n      };\r\n      this.games.set(gameId, gameData);\r\n    } else {\r\n      gameData = this.games.get(gameId);\r\n    }\r\n\r\n    // Check if player already in game\r\n    const existingPlayer = gameData.players.find(p => p.address === playerAddress);\r\n    if (existingPlayer) {\r\n      throw new Error('Already in this game');\r\n    }\r\n\r\n    // Add player to game\r\n    const player = {\r\n      address: playerAddress,\r\n      nickname: `Player${gameData.players.length + 1}`,\r\n      streak: 0,\r\n      maxStreak: 0,\r\n      status: 'waiting',\r\n      joinedAt: Date.now(),\r\n      hasPaid: true // Mock payment\r\n    };\r\n\r\n    gameData.players.push(player);\r\n    gameData.potSize += this.entryFee;\r\n\r\n    // Start game if we have 2+ players\r\n    if (gameData.players.length >= 2 && gameData.status === 'waiting') {\r\n      gameData.status = 'active';\r\n      gameData.startedAt = Date.now();\r\n      gameData.players[0].status = 'playing';\r\n    }\r\n\r\n    this.games.set(gameId, gameData);\r\n\r\n    return {\r\n      gameId,\r\n      players: gameData.players,\r\n      potSize: gameData.potSize,\r\n      houseFee: Math.round(gameData.potSize * this.houseFee * 100) / 100,\r\n      currentPlayer: gameData.players[gameData.currentPlayerIndex]?.address,\r\n      isPlayerTurn: gameData.currentPlayerIndex === gameData.players.length - 1,\r\n      gameStatus: gameData.status\r\n    };\r\n  }\r\n\r\n  // Start solo game\r\n  async startSoloGame(playerAddress, betAmount) {\r\n    console.log('ðŸŽ² Starting solo game:', playerAddress, 'bet:', betAmount);\r\n    \r\n    await this.simulateDelay(300);\r\n    \r\n    if (!playerAddress) {\r\n      throw new Error('Wallet not connected');\r\n    }\r\n\r\n    if (betAmount < 1 || betAmount > 100) {\r\n      throw new Error('Bet amount must be between 1 and 100 PUMP tokens');\r\n    }\r\n\r\n    // Check house balance - max streak of 7 for safety\r\n    const maxPayout = betAmount * Math.pow(2, 7);\r\n    if (this.mockHouseBalance < maxPayout) {\r\n      throw new Error(`House insufficient funds for this bet (max payout: ${maxPayout} PUMP)`);\r\n    }\r\n\r\n    const gameId = uuidv4();\r\n    const gameData = {\r\n      gameId,\r\n      type: 'solo',\r\n      status: 'active',\r\n      playerAddress,\r\n      betAmount,\r\n      currentStreak: 0,\r\n      maxStreak: 0,\r\n      createdAt: Date.now(),\r\n      houseBalance: this.mockHouseBalance\r\n    };\r\n\r\n    this.games.set(gameId, gameData);\r\n\r\n    return {\r\n      gameId,\r\n      betAmount,\r\n      currentStreak: 0,\r\n      maxStreak: 0,\r\n      potentialPayout: betAmount * 2,\r\n      houseBalance: this.mockHouseBalance,\r\n      isPlayerTurn: true,\r\n      gameStatus: 'active'\r\n    };\r\n  }\r\n\r\n  // Flip coin\r\n  async flipCoin(gameId, playerAddress) {\r\n    console.log('ðŸª™ Flipping coin:', gameId, playerAddress);\r\n    \r\n    await this.simulateDelay(1000); // Simulate coin flip animation time\r\n    \r\n    const gameData = this.games.get(gameId);\r\n    if (!gameData) {\r\n      throw new Error('Game not found');\r\n    }\r\n\r\n    const outcome = this.generateCoinFlip(gameId, playerAddress);\r\n    console.log('Flip result:', outcome);\r\n\r\n    if (gameData.type === 'solo') {\r\n      return this.handleSoloFlip(gameData, outcome);\r\n    } else {\r\n      return this.handleMultiplayerFlip(gameData, playerAddress, outcome);\r\n    }\r\n  }\r\n\r\n  // Handle solo mode flip\r\n  handleSoloFlip(gameData, outcome) {\r\n    if (outcome === 'heads') {\r\n      gameData.currentStreak += 1;\r\n      gameData.maxStreak = Math.max(gameData.maxStreak, gameData.currentStreak);\r\n      \r\n      const potentialPayout = gameData.betAmount * Math.pow(2, gameData.currentStreak);\r\n      \r\n      return {\r\n        outcome: 'heads',\r\n        streak: gameData.currentStreak,\r\n        maxStreak: gameData.maxStreak,\r\n        potentialPayout,\r\n        isPlayerTurn: true,\r\n        status: 'active'\r\n      };\r\n    } else {\r\n      // Bust\r\n      gameData.status = 'finished';\r\n      gameData.currentStreak = 0;\r\n      gameData.finishedAt = Date.now();\r\n      \r\n      // House wins the bet\r\n      this.mockHouseBalance += gameData.betAmount;\r\n      \r\n      return {\r\n        outcome: 'tails',\r\n        streak: 0,\r\n        maxStreak: gameData.maxStreak,\r\n        potentialPayout: 0,\r\n        isPlayerTurn: false,\r\n        status: 'busted'\r\n      };\r\n    }\r\n  }\r\n\r\n  // Handle multiplayer flip\r\n  handleMultiplayerFlip(gameData, playerAddress, outcome) {\r\n    const playerIndex = gameData.players.findIndex(p => p.address === playerAddress);\r\n    if (playerIndex === -1) {\r\n      throw new Error('Player not in game');\r\n    }\r\n\r\n    const player = gameData.players[playerIndex];\r\n    \r\n    if (gameData.currentPlayerIndex !== playerIndex) {\r\n      throw new Error('Not your turn');\r\n    }\r\n\r\n    if (outcome === 'heads') {\r\n      player.streak += 1;\r\n      player.maxStreak = Math.max(player.maxStreak, player.streak);\r\n      \r\n      return {\r\n        outcome: 'heads',\r\n        streak: player.streak,\r\n        maxStreak: player.maxStreak,\r\n        isPlayerTurn: true,\r\n        status: 'active'\r\n      };\r\n    } else {\r\n      // Bust - move to next player\r\n      player.status = 'busted';\r\n      player.streak = 0;\r\n      \r\n      // Find next active player\r\n      const nextPlayerIndex = this.findNextActivePlayer(gameData);\r\n      if (nextPlayerIndex === -1) {\r\n        // Game over - determine winner\r\n        this.endMultiplayerGame(gameData);\r\n      } else {\r\n        gameData.currentPlayerIndex = nextPlayerIndex;\r\n        gameData.players[nextPlayerIndex].status = 'playing';\r\n      }\r\n      \r\n      return {\r\n        outcome: 'tails',\r\n        streak: 0,\r\n        maxStreak: player.maxStreak,\r\n        isPlayerTurn: false,\r\n        status: player.status\r\n      };\r\n    }\r\n  }\r\n\r\n  // Cash out\r\n  async cashOut(gameId, playerAddress) {\r\n    console.log('ðŸ’° Cashing out:', gameId, playerAddress);\r\n    \r\n    await this.simulateDelay(500);\r\n    \r\n    const gameData = this.games.get(gameId);\r\n    if (!gameData) {\r\n      throw new Error('Game not found');\r\n    }\r\n\r\n    if (gameData.type === 'solo') {\r\n      gameData.status = 'cashed_out';\r\n      gameData.finalStreak = gameData.currentStreak;\r\n      gameData.finishedAt = Date.now();\r\n      \r\n      const payout = gameData.betAmount * Math.pow(2, gameData.currentStreak);\r\n      this.mockHouseBalance -= payout;\r\n      \r\n      return {\r\n        streak: gameData.currentStreak,\r\n        payout,\r\n        status: 'cashed_out'\r\n      };\r\n    } else {\r\n      const playerIndex = gameData.players.findIndex(p => p.address === playerAddress);\r\n      const player = gameData.players[playerIndex];\r\n      \r\n      player.status = 'cashed_out';\r\n      player.finalStreak = player.streak;\r\n      \r\n      // Move to next player\r\n      const nextPlayerIndex = this.findNextActivePlayer(gameData);\r\n      if (nextPlayerIndex === -1) {\r\n        this.endMultiplayerGame(gameData);\r\n      } else {\r\n        gameData.currentPlayerIndex = nextPlayerIndex;\r\n        gameData.players[nextPlayerIndex].status = 'playing';\r\n      }\r\n      \r\n      return {\r\n        streak: player.streak,\r\n        status: 'cashed_out'\r\n      };\r\n    }\r\n  }\r\n\r\n  // Claim winnings\r\n  async claimWinnings(gameId, playerAddress) {\r\n    console.log('ðŸ† Claiming winnings:', gameId, playerAddress);\r\n    \r\n    await this.simulateDelay(1000);\r\n    \r\n    const gameData = this.games.get(gameId);\r\n    if (!gameData) {\r\n      throw new Error('Game not found');\r\n    }\r\n\r\n    if (gameData.type === 'solo') {\r\n      if (gameData.status !== 'cashed_out') {\r\n        throw new Error('No winnings to claim');\r\n      }\r\n      \r\n      const payout = gameData.betAmount * Math.pow(2, gameData.finalStreak);\r\n      \r\n      // Clean up game\r\n      this.games.delete(gameId);\r\n      \r\n      return {\r\n        amount: payout,\r\n        type: 'solo'\r\n      };\r\n    } else {\r\n      if (gameData.status !== 'finished') {\r\n        throw new Error('Game not finished');\r\n      }\r\n      \r\n      const winner = gameData.players.find(p => p.address === playerAddress);\r\n      if (!winner || !winner.isWinner) {\r\n        throw new Error('You are not the winner');\r\n      }\r\n      \r\n      const totalPot = gameData.potSize;\r\n      const houseFeeAmount = totalPot * this.houseFee;\r\n      const winnings = totalPot - houseFeeAmount;\r\n      \r\n      // Clean up game\r\n      this.games.delete(gameId);\r\n      \r\n      return {\r\n        amount: winnings,\r\n        type: 'multiplayer',\r\n        houseFee: houseFeeAmount\r\n      };\r\n    }\r\n  }\r\n\r\n  // Helper methods\r\n  findActiveMultiplayerGame() {\r\n    for (const [gameId, gameData] of this.games) {\r\n      if (gameData.type === 'multiplayer' && \r\n          gameData.status === 'waiting' && \r\n          gameData.players.length < gameData.maxPlayers) {\r\n        return gameId;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  findNextActivePlayer(gameData) {\r\n    for (let i = gameData.currentPlayerIndex + 1; i < gameData.players.length; i++) {\r\n      if (gameData.players[i].status === 'waiting') {\r\n        return i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  endMultiplayerGame(gameData) {\r\n    gameData.status = 'finished';\r\n    gameData.finishedAt = Date.now();\r\n    \r\n    // Find winner (highest streak)\r\n    let winner = null;\r\n    let highestStreak = -1;\r\n    \r\n    for (const player of gameData.players) {\r\n      const finalStreak = player.finalStreak ?? player.maxStreak;\r\n      if (finalStreak > highestStreak) {\r\n        highestStreak = finalStreak;\r\n        winner = player;\r\n      }\r\n    }\r\n    \r\n    if (winner) {\r\n      winner.isWinner = true;\r\n      gameData.winner = winner.address;\r\n    }\r\n  }\r\n\r\n  simulateDelay(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n\r\n  // Get game state\r\n  getGameState(gameId) {\r\n    return this.games.get(gameId);\r\n  }\r\n\r\n  // Get payout table for solo mode\r\n  getPayoutTable(betAmount = 1) {\r\n    const payouts = [];\r\n    for (let streak = 1; streak <= 10; streak++) {\r\n      payouts.push({\r\n        streak,\r\n        payout: betAmount * Math.pow(2, streak),\r\n        odds: `1 in ${Math.pow(2, streak)}`\r\n      });\r\n    }\r\n    return payouts;\r\n  }\r\n\r\n  // Get game statistics\r\n  getGameStats() {\r\n    return {\r\n      activeGames: this.games.size,\r\n      houseBalance: this.mockHouseBalance,\r\n      totalPlayers: this.players.size\r\n    };\r\n  }\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}