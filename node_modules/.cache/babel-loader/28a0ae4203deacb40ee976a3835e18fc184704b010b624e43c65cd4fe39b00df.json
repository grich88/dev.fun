{"ast":null,"code":"export class WalletService {\n  constructor() {\n    this.mockWallets = new Map();\n    this.connectedWallet = null;\n    this.initialized = false;\n  }\n  initialize() {\n    if (this.initialized) return;\n    console.log('üí≥ WalletService initialized');\n    this.initialized = true;\n\n    // Create some mock wallets with balances\n    this.createMockWallets();\n  }\n  createMockWallets() {\n    const mockWallets = [{\n      address: 'PLAYER1_MOCK_WALLET_ADDRESS_123456789',\n      balance: 2.5,\n      // SOL\n      tokenBalance: 150,\n      // PUMP tokens\n      nickname: 'Player 1'\n    }, {\n      address: 'PLAYER2_MOCK_WALLET_ADDRESS_987654321',\n      balance: 1.8,\n      tokenBalance: 75,\n      nickname: 'Player 2'\n    }, {\n      address: 'PLAYER3_MOCK_WALLET_ADDRESS_456789123',\n      balance: 0.5,\n      tokenBalance: 25,\n      nickname: 'Player 3'\n    }];\n    mockWallets.forEach(wallet => {\n      this.mockWallets.set(wallet.address, wallet);\n    });\n  }\n\n  // Simulate wallet connection\n  async connect(wallet) {\n    console.log('üîó Connecting wallet...');\n\n    // Simulate connection delay\n    await this.simulateDelay(1000);\n\n    // For demo purposes, randomly select a mock wallet\n    const walletAddresses = Array.from(this.mockWallets.keys());\n    const randomAddress = walletAddresses[Math.floor(Math.random() * walletAddresses.length)];\n    const mockWallet = this.mockWallets.get(randomAddress);\n    this.connectedWallet = {\n      connected: true,\n      address: mockWallet.address,\n      balance: mockWallet.balance,\n      tokenBalance: mockWallet.tokenBalance,\n      nickname: mockWallet.nickname\n    };\n    console.log('‚úÖ Wallet connected:', this.connectedWallet);\n    return this.connectedWallet;\n  }\n\n  // Simulate wallet disconnection\n  async disconnect() {\n    console.log('üîå Disconnecting wallet...');\n    await this.simulateDelay(500);\n    this.connectedWallet = null;\n    console.log('‚ùå Wallet disconnected');\n  }\n\n  // Get current wallet info\n  getWalletInfo() {\n    return this.connectedWallet;\n  }\n\n  // Update balance (simulate after transactions)\n  async updateBalance(address) {\n    if (!address || !this.mockWallets.has(address)) {\n      throw new Error('Wallet not found');\n    }\n    await this.simulateDelay(300);\n    const wallet = this.mockWallets.get(address);\n\n    // Simulate small balance changes (for demo)\n    const change = (Math.random() - 0.5) * 10; // Random change between -5 and +5\n    wallet.tokenBalance = Math.max(0, wallet.tokenBalance + change);\n    if (this.connectedWallet && this.connectedWallet.address === address) {\n      this.connectedWallet.tokenBalance = wallet.tokenBalance;\n    }\n    return {\n      balance: wallet.balance,\n      tokenBalance: wallet.tokenBalance\n    };\n  }\n\n  // Simulate token transfer\n  async transferTokens(fromAddress, toAddress, amount) {\n    console.log(`üí∏ Transferring ${amount} tokens from ${fromAddress} to ${toAddress}`);\n    await this.simulateDelay(800);\n    const fromWallet = this.mockWallets.get(fromAddress);\n    const toWallet = this.mockWallets.get(toAddress);\n    if (!fromWallet) {\n      throw new Error('Sender wallet not found');\n    }\n    if (fromWallet.tokenBalance < amount) {\n      throw new Error('Insufficient token balance');\n    }\n\n    // Perform transfer\n    fromWallet.tokenBalance -= amount;\n    if (toWallet) {\n      toWallet.tokenBalance += amount;\n    }\n\n    // Update connected wallet if it's the sender\n    if (this.connectedWallet && this.connectedWallet.address === fromAddress) {\n      this.connectedWallet.tokenBalance = fromWallet.tokenBalance;\n    }\n    return {\n      success: true,\n      transactionHash: this.generateMockTxHash(),\n      fromBalance: fromWallet.tokenBalance,\n      toBalance: toWallet === null || toWallet === void 0 ? void 0 : toWallet.tokenBalance\n    };\n  }\n\n  // Check if wallet has sufficient balance\n  checkBalance(address, requiredAmount) {\n    const wallet = this.mockWallets.get(address);\n    if (!wallet) {\n      return {\n        sufficient: false,\n        balance: 0\n      };\n    }\n    return {\n      sufficient: wallet.tokenBalance >= requiredAmount,\n      balance: wallet.tokenBalance,\n      shortfall: Math.max(0, requiredAmount - wallet.tokenBalance)\n    };\n  }\n\n  // Get token balance for specific address\n  getTokenBalance(address) {\n    const wallet = this.mockWallets.get(address);\n    return wallet ? wallet.tokenBalance : 0;\n  }\n\n  // Get SOL balance for specific address\n  getSolBalance(address) {\n    const wallet = this.mockWallets.get(address);\n    return wallet ? wallet.balance : 0;\n  }\n\n  // Simulate airdrop (for testing)\n  async airdropTokens(address, amount) {\n    console.log(`ü™Ç Airdropping ${amount} tokens to ${address}`);\n    await this.simulateDelay(500);\n    const wallet = this.mockWallets.get(address);\n    if (!wallet) {\n      throw new Error('Wallet not found');\n    }\n    wallet.tokenBalance += amount;\n    if (this.connectedWallet && this.connectedWallet.address === address) {\n      this.connectedWallet.tokenBalance = wallet.tokenBalance;\n    }\n    return {\n      success: true,\n      newBalance: wallet.tokenBalance,\n      transactionHash: this.generateMockTxHash()\n    };\n  }\n\n  // Generate mock transaction hash\n  generateMockTxHash() {\n    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    let result = '';\n    for (let i = 0; i < 64; i++) {\n      result += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return result;\n  }\n\n  // Simulate network delay\n  simulateDelay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // Get all mock wallets (for testing)\n  getAllMockWallets() {\n    return Array.from(this.mockWallets.values());\n  }\n\n  // Create a new mock wallet\n  createMockWallet(nickname = 'New Player') {\n    const address = `MOCK_WALLET_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    const wallet = {\n      address,\n      balance: Math.random() * 5,\n      // Random SOL balance 0-5\n      tokenBalance: Math.floor(Math.random() * 200),\n      // Random token balance 0-200\n      nickname\n    };\n    this.mockWallets.set(address, wallet);\n    return wallet;\n  }\n\n  // Switch to different mock wallet (for testing)\n  async switchToWallet(address) {\n    const wallet = this.mockWallets.get(address);\n    if (!wallet) {\n      throw new Error('Wallet not found');\n    }\n    await this.simulateDelay(800);\n    this.connectedWallet = {\n      connected: true,\n      address: wallet.address,\n      balance: wallet.balance,\n      tokenBalance: wallet.tokenBalance,\n      nickname: wallet.nickname\n    };\n    return this.connectedWallet;\n  }\n\n  // Get wallet connection status\n  isConnected() {\n    return this.connectedWallet !== null;\n  }\n\n  // Get connected wallet address\n  getConnectedAddress() {\n    var _this$connectedWallet;\n    return ((_this$connectedWallet = this.connectedWallet) === null || _this$connectedWallet === void 0 ? void 0 : _this$connectedWallet.address) || null;\n  }\n\n  // Format wallet address for display\n  formatAddress(address) {\n    if (!address) return '';\n    if (address.length <= 8) return address;\n    return `${address.substring(0, 4)}...${address.substring(address.length - 4)}`;\n  }\n\n  // Simulate transaction fee calculation\n  calculateTransactionFee() {\n    // Typical Solana transaction fee\n    return 0.000005; // 5000 lamports in SOL\n  }\n\n  // Check if wallet has enough SOL for transaction fees\n  checkSolForFees(address) {\n    const wallet = this.mockWallets.get(address);\n    const requiredFee = this.calculateTransactionFee();\n    return {\n      sufficient: wallet ? wallet.balance >= requiredFee : false,\n      balance: wallet ? wallet.balance : 0,\n      requiredFee\n    };\n  }\n}","map":{"version":3,"names":["WalletService","constructor","mockWallets","Map","connectedWallet","initialized","initialize","console","log","createMockWallets","address","balance","tokenBalance","nickname","forEach","wallet","set","connect","simulateDelay","walletAddresses","Array","from","keys","randomAddress","Math","floor","random","length","mockWallet","get","connected","disconnect","getWalletInfo","updateBalance","has","Error","change","max","transferTokens","fromAddress","toAddress","amount","fromWallet","toWallet","success","transactionHash","generateMockTxHash","fromBalance","toBalance","checkBalance","requiredAmount","sufficient","shortfall","getTokenBalance","getSolBalance","airdropTokens","newBalance","chars","result","i","charAt","ms","Promise","resolve","setTimeout","getAllMockWallets","values","createMockWallet","Date","now","toString","substr","switchToWallet","isConnected","getConnectedAddress","_this$connectedWallet","formatAddress","substring","calculateTransactionFee","checkSolForFees","requiredFee"],"sources":["C:/dev.fun/src/services/WalletService.js"],"sourcesContent":["export class WalletService {\r\n  constructor() {\r\n    this.mockWallets = new Map();\r\n    this.connectedWallet = null;\r\n    this.initialized = false;\r\n  }\r\n\r\n  initialize() {\r\n    if (this.initialized) return;\r\n    \r\n    console.log('üí≥ WalletService initialized');\r\n    this.initialized = true;\r\n    \r\n    // Create some mock wallets with balances\r\n    this.createMockWallets();\r\n  }\r\n\r\n  createMockWallets() {\r\n    const mockWallets = [\r\n      {\r\n        address: 'PLAYER1_MOCK_WALLET_ADDRESS_123456789',\r\n        balance: 2.5, // SOL\r\n        tokenBalance: 150, // PUMP tokens\r\n        nickname: 'Player 1'\r\n      },\r\n      {\r\n        address: 'PLAYER2_MOCK_WALLET_ADDRESS_987654321',\r\n        balance: 1.8,\r\n        tokenBalance: 75,\r\n        nickname: 'Player 2'\r\n      },\r\n      {\r\n        address: 'PLAYER3_MOCK_WALLET_ADDRESS_456789123',\r\n        balance: 0.5,\r\n        tokenBalance: 25,\r\n        nickname: 'Player 3'\r\n      }\r\n    ];\r\n\r\n    mockWallets.forEach(wallet => {\r\n      this.mockWallets.set(wallet.address, wallet);\r\n    });\r\n  }\r\n\r\n  // Simulate wallet connection\r\n  async connect(wallet) {\r\n    console.log('üîó Connecting wallet...');\r\n    \r\n    // Simulate connection delay\r\n    await this.simulateDelay(1000);\r\n    \r\n    // For demo purposes, randomly select a mock wallet\r\n    const walletAddresses = Array.from(this.mockWallets.keys());\r\n    const randomAddress = walletAddresses[Math.floor(Math.random() * walletAddresses.length)];\r\n    const mockWallet = this.mockWallets.get(randomAddress);\r\n    \r\n    this.connectedWallet = {\r\n      connected: true,\r\n      address: mockWallet.address,\r\n      balance: mockWallet.balance,\r\n      tokenBalance: mockWallet.tokenBalance,\r\n      nickname: mockWallet.nickname\r\n    };\r\n\r\n    console.log('‚úÖ Wallet connected:', this.connectedWallet);\r\n    \r\n    return this.connectedWallet;\r\n  }\r\n\r\n  // Simulate wallet disconnection\r\n  async disconnect() {\r\n    console.log('üîå Disconnecting wallet...');\r\n    \r\n    await this.simulateDelay(500);\r\n    \r\n    this.connectedWallet = null;\r\n    \r\n    console.log('‚ùå Wallet disconnected');\r\n  }\r\n\r\n  // Get current wallet info\r\n  getWalletInfo() {\r\n    return this.connectedWallet;\r\n  }\r\n\r\n  // Update balance (simulate after transactions)\r\n  async updateBalance(address) {\r\n    if (!address || !this.mockWallets.has(address)) {\r\n      throw new Error('Wallet not found');\r\n    }\r\n\r\n    await this.simulateDelay(300);\r\n    \r\n    const wallet = this.mockWallets.get(address);\r\n    \r\n    // Simulate small balance changes (for demo)\r\n    const change = (Math.random() - 0.5) * 10; // Random change between -5 and +5\r\n    wallet.tokenBalance = Math.max(0, wallet.tokenBalance + change);\r\n    \r\n    if (this.connectedWallet && this.connectedWallet.address === address) {\r\n      this.connectedWallet.tokenBalance = wallet.tokenBalance;\r\n    }\r\n\r\n    return {\r\n      balance: wallet.balance,\r\n      tokenBalance: wallet.tokenBalance\r\n    };\r\n  }\r\n\r\n  // Simulate token transfer\r\n  async transferTokens(fromAddress, toAddress, amount) {\r\n    console.log(`üí∏ Transferring ${amount} tokens from ${fromAddress} to ${toAddress}`);\r\n    \r\n    await this.simulateDelay(800);\r\n    \r\n    const fromWallet = this.mockWallets.get(fromAddress);\r\n    const toWallet = this.mockWallets.get(toAddress);\r\n    \r\n    if (!fromWallet) {\r\n      throw new Error('Sender wallet not found');\r\n    }\r\n    \r\n    if (fromWallet.tokenBalance < amount) {\r\n      throw new Error('Insufficient token balance');\r\n    }\r\n    \r\n    // Perform transfer\r\n    fromWallet.tokenBalance -= amount;\r\n    \r\n    if (toWallet) {\r\n      toWallet.tokenBalance += amount;\r\n    }\r\n    \r\n    // Update connected wallet if it's the sender\r\n    if (this.connectedWallet && this.connectedWallet.address === fromAddress) {\r\n      this.connectedWallet.tokenBalance = fromWallet.tokenBalance;\r\n    }\r\n    \r\n    return {\r\n      success: true,\r\n      transactionHash: this.generateMockTxHash(),\r\n      fromBalance: fromWallet.tokenBalance,\r\n      toBalance: toWallet?.tokenBalance\r\n    };\r\n  }\r\n\r\n  // Check if wallet has sufficient balance\r\n  checkBalance(address, requiredAmount) {\r\n    const wallet = this.mockWallets.get(address);\r\n    if (!wallet) {\r\n      return { sufficient: false, balance: 0 };\r\n    }\r\n    \r\n    return {\r\n      sufficient: wallet.tokenBalance >= requiredAmount,\r\n      balance: wallet.tokenBalance,\r\n      shortfall: Math.max(0, requiredAmount - wallet.tokenBalance)\r\n    };\r\n  }\r\n\r\n  // Get token balance for specific address\r\n  getTokenBalance(address) {\r\n    const wallet = this.mockWallets.get(address);\r\n    return wallet ? wallet.tokenBalance : 0;\r\n  }\r\n\r\n  // Get SOL balance for specific address\r\n  getSolBalance(address) {\r\n    const wallet = this.mockWallets.get(address);\r\n    return wallet ? wallet.balance : 0;\r\n  }\r\n\r\n  // Simulate airdrop (for testing)\r\n  async airdropTokens(address, amount) {\r\n    console.log(`ü™Ç Airdropping ${amount} tokens to ${address}`);\r\n    \r\n    await this.simulateDelay(500);\r\n    \r\n    const wallet = this.mockWallets.get(address);\r\n    if (!wallet) {\r\n      throw new Error('Wallet not found');\r\n    }\r\n    \r\n    wallet.tokenBalance += amount;\r\n    \r\n    if (this.connectedWallet && this.connectedWallet.address === address) {\r\n      this.connectedWallet.tokenBalance = wallet.tokenBalance;\r\n    }\r\n    \r\n    return {\r\n      success: true,\r\n      newBalance: wallet.tokenBalance,\r\n      transactionHash: this.generateMockTxHash()\r\n    };\r\n  }\r\n\r\n  // Generate mock transaction hash\r\n  generateMockTxHash() {\r\n    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\r\n    let result = '';\r\n    for (let i = 0; i < 64; i++) {\r\n      result += chars.charAt(Math.floor(Math.random() * chars.length));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // Simulate network delay\r\n  simulateDelay(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n\r\n  // Get all mock wallets (for testing)\r\n  getAllMockWallets() {\r\n    return Array.from(this.mockWallets.values());\r\n  }\r\n\r\n  // Create a new mock wallet\r\n  createMockWallet(nickname = 'New Player') {\r\n    const address = `MOCK_WALLET_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n    const wallet = {\r\n      address,\r\n      balance: Math.random() * 5, // Random SOL balance 0-5\r\n      tokenBalance: Math.floor(Math.random() * 200), // Random token balance 0-200\r\n      nickname\r\n    };\r\n    \r\n    this.mockWallets.set(address, wallet);\r\n    return wallet;\r\n  }\r\n\r\n  // Switch to different mock wallet (for testing)\r\n  async switchToWallet(address) {\r\n    const wallet = this.mockWallets.get(address);\r\n    if (!wallet) {\r\n      throw new Error('Wallet not found');\r\n    }\r\n    \r\n    await this.simulateDelay(800);\r\n    \r\n    this.connectedWallet = {\r\n      connected: true,\r\n      address: wallet.address,\r\n      balance: wallet.balance,\r\n      tokenBalance: wallet.tokenBalance,\r\n      nickname: wallet.nickname\r\n    };\r\n    \r\n    return this.connectedWallet;\r\n  }\r\n\r\n  // Get wallet connection status\r\n  isConnected() {\r\n    return this.connectedWallet !== null;\r\n  }\r\n\r\n  // Get connected wallet address\r\n  getConnectedAddress() {\r\n    return this.connectedWallet?.address || null;\r\n  }\r\n\r\n  // Format wallet address for display\r\n  formatAddress(address) {\r\n    if (!address) return '';\r\n    \r\n    if (address.length <= 8) return address;\r\n    \r\n    return `${address.substring(0, 4)}...${address.substring(address.length - 4)}`;\r\n  }\r\n\r\n  // Simulate transaction fee calculation\r\n  calculateTransactionFee() {\r\n    // Typical Solana transaction fee\r\n    return 0.000005; // 5000 lamports in SOL\r\n  }\r\n\r\n  // Check if wallet has enough SOL for transaction fees\r\n  checkSolForFees(address) {\r\n    const wallet = this.mockWallets.get(address);\r\n    const requiredFee = this.calculateTransactionFee();\r\n    \r\n    return {\r\n      sufficient: wallet ? wallet.balance >= requiredFee : false,\r\n      balance: wallet ? wallet.balance : 0,\r\n      requiredFee\r\n    };\r\n  }\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}